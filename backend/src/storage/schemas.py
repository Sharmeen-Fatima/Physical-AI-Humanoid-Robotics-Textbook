"""
Pydantic data models for the RAG Chatbot System.

Defines schemas for all entities: BookPage, TextChunk, ChunkMetadata,
Query, RetrievalResult, ChatResponse, and SessionData.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, field_validator


class BookPage(BaseModel):
    """Represents a single web page from the book."""

    url: str = Field(..., description="Full URL of the page")
    cleaned_text: str = Field(..., description="Extracted text after HTML cleaning", min_length=100)
    section_title: Optional[str] = Field(None, description="Page/section heading")
    scrape_timestamp: datetime = Field(default_factory=datetime.utcnow, description="When the page was scraped")
    content_hash: str = Field(..., description="SHA-256 hash of cleaned_text")

    @field_validator("url")
    @classmethod
    def validate_url(cls, v: str) -> str:
        """Validate URL format."""
        if not v.startswith(("http://", "https://")):
            raise ValueError("URL must start with http:// or https://")
        return v


class TextChunk(BaseModel):
    """Represents a semantic segment of text from a BookPage."""

    chunk_id: str = Field(default_factory=lambda: str(uuid4()), description="Unique identifier (UUID)")
    text: str = Field(..., description="Chunk content", min_length=100)
    chunk_index: int = Field(..., description="Position within parent page", ge=0)
    parent_url: str = Field(..., description="URL of source BookPage")
    section_title: Optional[str] = Field(None, description="Section/chapter identifier")
    char_start: int = Field(..., description="Character offset in original page", ge=0)
    char_end: int = Field(..., description="End character offset", ge=0)
    overlap_start: int = Field(default=0, description="Tokens overlapping with previous chunk", ge=0)
    overlap_end: int = Field(default=0, description="Tokens overlapping with next chunk", ge=0)

    @field_validator("char_end")
    @classmethod
    def validate_char_end(cls, v: int, info) -> int:
        """Validate char_end > char_start."""
        if "char_start" in info.data and v <= info.data["char_start"]:
            raise ValueError("char_end must be greater than char_start")
        return v


class ChunkMetadata(BaseModel):
    """Metadata stored alongside vectors in Qdrant."""

    text: str = Field(..., description="Full chunk text for display/context")
    url: str = Field(..., description="Source page URL for citation")
    section: Optional[str] = Field(None, description="Section/chapter title")
    chunk_index: int = Field(..., description="Position within page", ge=0)
    ingestion_timestamp: str = Field(..., description="When chunk was ingested (ISO 8601)")
    book_version: Optional[str] = Field(None, description="Version identifier for content tracking")

    @field_validator("url")
    @classmethod
    def validate_url(cls, v: str) -> str:
        """Validate URL format."""
        if not v.startswith(("http://", "https://")):
            raise ValueError("URL must start with http:// or https://")
        return v


class Query(BaseModel):
    """Represents a user question submitted to the chatbot."""

    query_id: str = Field(default_factory=lambda: str(uuid4()), description="Unique identifier")
    query_text: str = Field(..., description="User's question", max_length=500)
    query_embedding: Optional[List[float]] = Field(None, description="Embedding of query")
    session_id: Optional[str] = Field(None, description="Associated session for multi-turn")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="When query was submitted")

    @field_validator("query_text")
    @classmethod
    def validate_query_text(cls, v: str) -> str:
        """Validate query text is non-empty."""
        if not v.strip():
            raise ValueError("Query text cannot be empty")
        return v.strip()


class RetrievalResult(BaseModel):
    """Represents chunks retrieved from Qdrant for a query."""

    chunk_id: str = Field(..., description="Retrieved chunk ID")
    text: str = Field(..., description="Text of the retrieved chunk")
    url: str = Field(..., description="Source page URL for citation")
    section: str = Field(..., description="Section/chapter title")
    chunk_index: int = Field(..., description="Position within page", ge=0)
    similarity_score: float = Field(..., description="Cosine similarity score", ge=0.0, le=1.0)
    rank: int = Field(..., description="Ranking position (1 = most relevant)", ge=1)


class ChatResponse(BaseModel):
    """Represents the final answer generated by Gemini."""

    query: str = Field(..., description="User's question")
    answer: str = Field(..., description="Generated answer or fallback message")
    sources: List[Dict[str, Any]] = Field(
        default_factory=list, description="Source references with URL, section, rank, and score"
    )
    num_sources: int = Field(default=0, description="Number of sources used")
    model: str = Field(..., description="Gemini model identifier")
    temperature: float = Field(..., description="Temperature used for generation")
    is_grounded: bool = Field(default=True, description="Whether answer is grounded in context")
    has_citations: bool = Field(default=False, description="Whether answer includes source citations")

    @field_validator("answer")
    @classmethod
    def validate_answer_text(cls, v: str) -> str:
        """Validate answer text is non-empty."""
        if not v.strip():
            raise ValueError("Answer text cannot be empty")
        return v.strip()


class SessionData(BaseModel):
    """Represents a conversation session for context tracking."""

    session_id: str = Field(default_factory=lambda: str(uuid4()), description="Unique session identifier")
    created_at: str = Field(..., description="Session creation timestamp (ISO format)")
    last_activity: str = Field(..., description="Last interaction timestamp (ISO format)")
    conversation_history: List[Dict[str, str]] = Field(
        default_factory=list, description="Conversation history with role and content"
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional session metadata"
    )
